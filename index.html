<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebCraft Pro</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        
        /* Crosshair */
        #crosshair { 
            position: fixed; top: 50%; left: 50%; width: 16px; height: 16px;
            transform: translate(-50%, -50%); pointer-events: none; z-index: 1000;
        }
        #crosshair::before, #crosshair::after { content: ''; position: absolute; background: white; box-shadow: 0 0 2px black; }
        #crosshair::before { width: 16px; height: 2px; top: 7px; }
        #crosshair::after { width: 2px; height: 16px; left: 7px; }
        
        /* Modern UI */
        #ui-container { position: fixed; top: 20px; left: 20px; color: white; text-shadow: 2px 2px black; pointer-events: none; }
        .stat-bar { width: 200px; height: 10px; background: rgba(0,0,0,0.5); border: 2px solid #333; margin: 5px 0; border-radius: 5px; overflow: hidden; }
        #health-fill { width: 100%; height: 100%; background: #ff4757; transition: width 0.3s; }
        #hunger-fill { width: 100%; height: 100%; background: #ffa502; transition: width 0.3s; }

        /* Clean Hotbar */
        #hotbar {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 8px; background: rgba(0,0,0,0.7);
            padding: 8px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.2);
            backdrop-filter: blur(5px);
        }
        .slot {
            width: 45px; height: 45px; border-radius: 8px;
            border: 2px solid transparent; background-size: cover;
            transition: transform 0.1s;
        }
        .slot.active { border-color: #fff; transform: scale(1.1); box-shadow: 0 0 15px rgba(255,255,255,0.5); }

        /* Settings Menu */
        #settings-btn { position: fixed; top: 20px; right: 20px; padding: 8px 15px; background: rgba(0,0,0,0.6); color: white; border: 1px solid white; cursor: pointer; pointer-events: all; }
        #settings-menu { 
            display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9); color: white; padding: 30px; border-radius: 15px; width: 300px;
            pointer-events: all; border: 1px solid #444;
        }
    </style>
</head>
<body>

<div id="crosshair"></div>

<div id="ui-container">
    <div style="font-size: 24px; font-weight: bold; margin-bottom: 10px;">WebCraft Pro</div>
    Health <div class="stat-bar"><div id="health-fill"></div></div>
    Hunger <div class="stat-bar"><div id="hunger-fill"></div></div>
    <div id="debug" style="margin-top: 10px; font-size: 12px; opacity: 0.8;">FPS: 60 | Pos: 0, 0, 0</div>
</div>

<button id="settings-btn" onclick="toggleSettings()">SETTINGS</button>
<div id="settings-menu">
    <h3>Settings</h3>
    <label><input type="checkbox" id="shader-toggle" onchange="updateShaders()"> Enable Shaders</label><br><br>
    <label>Render Distance: <input type="range" min="2" max="10" value="5" id="dist-slider"></label><br><br>
    <button onclick="toggleSettings()" style="width: 100%;">Close</button>
</div>

<div id="hotbar"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// --- CONFIG & STATE ---
let stats = { health: 100, hunger: 100, dimension: 'overworld' };
let settings = { shaders: false, renderDist: 5 };

// --- TEXTURE GENERATOR ---
function createNoiseTexture(color, noise = 0.2) {
    const canvas = document.createElement('canvas');
    canvas.width = 32; canvas.height = 32;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = color;
    ctx.fillRect(0, 0, 32, 32);
    for (let i = 0; i < 500; i++) {
        const val = Math.random() * noise;
        ctx.fillStyle = `rgba(0,0,0,${val})`;
        ctx.fillRect(Math.random()*32, Math.random()*32, 1, 1);
    }
    const tex = new THREE.CanvasTexture(canvas);
    tex.magFilter = THREE.NearestFilter;
    return tex;
}

const blockData = {
    1: { name: 'Grass', color: '#5d9948', tex: null },
    2: { name: 'Stone', color: '#808080', tex: null },
    3: { name: 'Dirt', color: '#795548', tex: null },
    4: { name: 'Sand', color: '#e0d5a8', tex: null },
    5: { name: 'Wood', color: '#5d4037', tex: null },
    6: { name: 'Leaves', color: '#2ed573', tex: null }
};

// Initialize textures
Object.keys(blockData).forEach(key => {
    blockData[key].tex = createNoiseTexture(blockData[key].color);
});

// --- SCENE SETUP ---
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87CEEB);
scene.fog = new THREE.Fog(0x87CEEB, 20, 100);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const ambient = new THREE.AmbientLight(0xffffff, 0.7);
scene.add(ambient);
const sun = new THREE.DirectionalLight(0xffffff, 0.5);
sun.position.set(10, 20, 10);
scene.add(sun);

// --- WORLD GEN ---
const CHUNK_SIZE = 16;
const world = new Map();
const chunks = new Map();

function getBlock(x, y, z) { return world.get(`${x},${y},${z}`) || 0; }
function setBlock(x, y, z, t) { t === 0 ? world.delete(`${x},${y},${z}`) : world.set(`${x},${y},${z}`, t); }

class Chunk {
    constructor(cx, cz) {
        this.cx = cx; this.cz = cz;
        this.mesh = new THREE.Group();
        this.generate();
        this.build();
        scene.add(this.mesh);
    }
    generate() {
        for(let x=0; x<CHUNK_SIZE; x++) {
            for(let z=0; z<CHUNK_SIZE; z++) {
                const wx = this.cx * CHUNK_SIZE + x;
                const wz = this.cz * CHUNK_SIZE + z;
                const h = Math.floor(Math.sin(wx*0.1)*3 + Math.cos(wz*0.1)*3 + 10);
                for(let y=0; y<=h; y++) {
                    let type = y === h ? 1 : (y > h-3 ? 3 : 2);
                    setBlock(wx, y, wz, type);
                }
            }
        }
    }
    build() {
        this.mesh.clear();
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const typesInChunk = {};
        
        for(let x=0; x<CHUNK_SIZE; x++) {
            for(let z=0; z<CHUNK_SIZE; z++) {
                for(let y=0; y<30; y++) {
                    const wx = this.cx * CHUNK_SIZE + x;
                    const type = getBlock(wx, y, this.cz * CHUNK_SIZE + z);
                    if(type > 0) {
                        if(!typesInChunk[type]) typesInChunk[type] = [];
                        typesInChunk[type].push(new THREE.Vector3(wx, y, this.cz * CHUNK_SIZE + z));
                    }
                }
            }
        }

        Object.keys(typesInChunk).forEach(type => {
            const positions = typesInChunk[type];
            const instanced = new THREE.InstancedMesh(
                geometry, 
                new THREE.MeshLambertMaterial({ map: blockData[type].tex }), 
                positions.length
            );
            const dummy = new THREE.Object3D();
            positions.forEach((pos, i) => {
                dummy.position.copy(pos);
                dummy.updateMatrix();
                instanced.setMatrixAt(i, dummy.matrix);
            });
            this.mesh.add(instanced);
        });
    }
}

// --- PLAYER & CONTROLS ---
let move = { f:0, b:0, l:0, r:0, jump: false };
let player = { pos: new THREE.Vector3(0, 20, 0), vel: new THREE.Vector3(), targetY: 20, slot: 1 };

document.addEventListener('keydown', e => {
    if(e.code === 'KeyW') move.f = 1;
    if(e.code === 'KeyS') move.b = 1;
    if(e.code === 'KeyA') move.l = 1; // Corrected
    if(e.code === 'KeyD') move.r = 1; // Corrected
    if(e.code === 'Space') move.jump = true;
    if(e.code.includes('Digit')) player.slot = parseInt(e.key);
    updateUI();
});
document.addEventListener('keyup', e => {
    if(e.code === 'KeyW') move.f = 0;
    if(e.code === 'KeyS') move.b = 0;
    if(e.code === 'KeyA') move.l = 0;
    if(e.code === 'KeyD') move.r = 0;
});

// Mouse Lock
renderer.domElement.onclick = () => renderer.domElement.requestPointerLock();
let yaw = 0, pitch = 0;
window.addEventListener('mousemove', e => {
    if(document.pointerLockElement) {
        yaw -= e.movementX * 0.002;
        pitch -= e.movementY * 0.002;
        pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, pitch));
        camera.rotation.set(pitch, yaw, 0, 'YXZ');
    }
});

// --- MAIN LOOP ---
function updateUI() {
    document.getElementById('health-fill').style.width = stats.health + '%';
    document.getElementById('hunger-fill').style.width = stats.hunger + '%';
    const slots = document.querySelectorAll('.slot');
    slots.forEach((s, i) => s.className = `slot ${i+1 === player.slot ? 'active' : ''}`);
}

function initHotbar() {
    const hb = document.getElementById('hotbar');
    for(let i=1; i<=6; i++) {
        const s = document.createElement('div');
        s.className = `slot ${i===1?'active':''}`;
        s.style.backgroundColor = blockData[i].color;
        hb.appendChild(s);
    }
}
initHotbar();

function toggleSettings() {
    const m = document.getElementById('settings-menu');
    m.style.display = m.style.display === 'block' ? 'none' : 'block';
}

function updateShaders() {
    settings.shaders = document.getElementById('shader-toggle').checked;
    // Simple shader effect using renderer exposure
    renderer.toneMappingExposure = settings.shaders ? 1.5 : 1.0;
}

let lastTime = performance.now();
function animate() {
    const now = performance.now();
    const dt = (now - lastTime) / 1000;
    lastTime = now;

    // Movement Physics
    const dir = new THREE.Vector3();
    camera.getWorldDirection(dir);
    dir.y = 0; dir.normalize();
    const side = new THREE.Vector3().crossVectors(dir, new THREE.Vector3(0,1,0));

    const speed = 10;
    player.vel.x = (move.r - move.l) * speed;
    player.vel.z = (move.b - move.f) * speed;

    const moveVec = new THREE.Vector3()
        .addScaledVector(dir, -player.vel.z)
        .addScaledVector(side, player.vel.x);
    
    player.pos.addScaledVector(moveVec, dt);

    // Smooth Step Collision
    const currentH = Math.floor(player.pos.x);
    const currentZ = Math.floor(player.pos.z);
    const groundY = Math.floor(Math.sin(player.pos.x*0.1)*3 + Math.cos(player.pos.z*0.1)*3 + 10) + 2;
    
    // This creates the smooth "walking up" feel
    player.targetY = groundY;
    player.pos.y += (player.targetY - player.pos.y) * 0.1; 

    camera.position.copy(player.pos);

    // Chunk Loading
    const cx = Math.floor(player.pos.x / CHUNK_SIZE);
    const cz = Math.floor(player.pos.z / CHUNK_SIZE);
    for(let x=-2; x<=2; x++) {
        for(let z=-2; z<=2; z++) {
            const key = `${cx+x},${cz+z}`;
            if(!chunks.has(key)) chunks.set(key, new Chunk(cx+x, cz+z));
        }
    }

    // Hunger Drain
    if(Math.abs(player.vel.length()) > 0) {
        stats.hunger = Math.max(0, stats.hunger - 0.01);
        updateUI();
    }

    renderer.render(scene, camera);
    requestAnimationFrame(animate);
}

animate();
</script>
</body>
</html>
